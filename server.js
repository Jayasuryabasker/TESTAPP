import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import { Innertube, UniversalCache } from 'youtubei.js';
import OpenAI from 'openai';

dotenv.config();

const app = express();
const PORT = 3000;

app.use(cors());
app.use(express.json());

let youtube;

// Initialize Innertube
(async () => {
    youtube = await Innertube.create({
        cache: new UniversalCache(false),
        generate_session_locally: true
    });
    console.log('YouTube client initialized');
})();

// --- Helper Functions ---

const getVideoId = (url) => {
    try {
        const urlObj = new URL(url);
        if (urlObj.hostname.includes('youtube.com')) {
            return urlObj.searchParams.get('v');
        } else if (urlObj.hostname.includes('youtu.be')) {
            return urlObj.pathname.slice(1);
        }
    } catch (e) {
        return null;
    }
    return null;
};

// --- Endpoints ---

// 1. Get Transcript (Default or Specific Lang)
app.get('/transcript', async (req, res) => {
    const { videoId, lang } = req.query;
    if (!videoId) return res.status(400).json({ error: 'Missing videoId' });

    if (!youtube) return res.status(503).json({ error: 'YouTube client not ready' });

    try {
        const info = await youtube.getInfo(videoId);
        let transcriptItems = [];
        let fullText = "";

        try {
            const transcriptData = await info.getTranscript();
            if (transcriptData && transcriptData.transcript) {
                const segments = transcriptData.transcript.content.body.initial_segments;
                transcriptItems = segments.map(seg => ({
                    text: seg.snippet.text,
                    offset: Number(seg.start_ms),
                    duration: Number(seg.end_ms) - Number(seg.start_ms)
                }));
                fullText = transcriptItems.map(item => item.text).join(' ');
            }
        } catch (err) {
            console.log(`Standard getTranscript failed (${err.message}). Attempting fallback...`);

            if (info.captions && info.captions.caption_tracks && info.captions.caption_tracks.length > 0) {
                // Determine track to use (prefer 'en' or first available)
                const track = info.captions.caption_tracks.find(t => t.language_code === (lang || 'en')) || info.captions.caption_tracks[0];
                console.log(`Fallback using track: ${track.language_code}`);

                const response = await fetch(`${track.base_url}&fmt=json3`);
                if (!response.ok) throw new Error(`Fallback fetch failed: ${response.statusText}`);

                const json = await response.json();
                const events = json.events || [];

                transcriptItems = events
                    .map(e => {
                        const text = e.segs ? e.segs.map(s => s.utf8).join('') : '';
                        return {
                            text: text.replace(/\n/g, ' ').trim(),
                            offset: e.tStartMs,
                            duration: e.dDurationMs || 0
                        };
                    })
                    .filter(item => item.text.length > 0);

                fullText = transcriptItems.map(item => item.text).join(' ');
            } else {
                throw err; // Re-throw if no fallback possible
            }
        }

        if (!transcriptItems.length) {
            return res.status(404).json({ error: 'No transcript found for this video' });
        }

        res.json({
            items: transcriptItems,
            fullText
        });
    } catch (error) {
        console.error('Transcript Error:', error.message);
        res.status(500).json({ error: 'Failed to fetch transcript', details: error.message });
    }
});

// 2. Get Available Languages (for source selection if needed, or just info)
app.get('/languages', async (req, res) => {
    const { videoId } = req.query;
    if (!videoId) return res.status(400).json({ error: 'Missing videoId' });

    if (!youtube) return res.status(503).json({ error: 'YouTube client not ready' });

    try {
        const info = await youtube.getInfo(videoId);
        const captions = info.captions; // accessing captions

        if (captions && captions.caption_tracks) {
            const languages = captions.caption_tracks.map(track => ({
                code: track.language_code,
                name: track.name.text,
                isAutoGenerated: track.kind === 'asr',
                baseUrl: track.base_url // Internal helpful
            }));
            res.json(languages);
        } else {
            res.json([]);
        }
    } catch (error) {
        console.error('Lang Error:', error);
        res.status(500).json({ error: 'Failed to fetch languages' });
    }
});

// 3. Translate Text (Using OpenAI)
app.post('/translate', async (req, res) => {
    const { text, targetLanguage, apiKey, useMock } = req.body;

    if (!text || !targetLanguage) {
        return res.status(400).json({ error: 'Missing text or targetLanguage' });
    }

    if (useMock) {
        console.log('Using MOCK translation');
        // Simulate a delay
        await new Promise(resolve => setTimeout(resolve, 1000));

        const mockText = `[MOCK TRANSLATION to ${targetLanguage}]\n` +
            text.split(' ').map(w => `le-${w}`).join(' ');

        return res.json({ translatedText: mockText });
    }

    const currentKey = apiKey || process.env.OPENAI_API_KEY;

    if (!currentKey) {
        return res.status(401).json({ error: 'Missing OpenAI API Key' });
    }

    try {
        const openai = new OpenAI({ apiKey: currentKey });

        const completion = await openai.chat.completions.create({
            model: "gpt-4o-mini",
            messages: [
                { role: "system", content: "You are a helpful translator. Translate the following transcript text into the target language. Preserve the meaning accurately." },
                { role: "user", content: `Translate this to ${targetLanguage}:\n\n${text}` }
            ],
            max_tokens: 2000,
        });

        const translatedText = completion.choices[0].message.content;
        res.json({ translatedText });

    } catch (error) {
        console.error('OpenAI Error:', error.message);
        res.status(500).json({ error: 'Translation failed', details: error.message });
    }
});

app.listen(PORT, () => {
    console.log(`Server running on http://localhost:${PORT}`);
});
